// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'inspect_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$InspectState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InspectStateCopyWith<$Res> {
  factory $InspectStateCopyWith(
          InspectState value, $Res Function(InspectState) then) =
      _$InspectStateCopyWithImpl<$Res, InspectState>;
}

/// @nodoc
class _$InspectStateCopyWithImpl<$Res, $Val extends InspectState>
    implements $InspectStateCopyWith<$Res> {
  _$InspectStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_Initial>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'InspectState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements InspectState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$$_LoadingCopyWith<$Res> {
  factory _$$_LoadingCopyWith(
          _$_Loading value, $Res Function(_$_Loading) then) =
      __$$_LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LoadingCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_Loading>
    implements _$$_LoadingCopyWith<$Res> {
  __$$_LoadingCopyWithImpl(_$_Loading _value, $Res Function(_$_Loading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Loading implements _Loading {
  const _$_Loading();

  @override
  String toString() {
    return 'InspectState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements InspectState {
  const factory _Loading() = _$_Loading;
}

/// @nodoc
abstract class _$$_LoadingContentCopyWith<$Res> {
  factory _$$_LoadingContentCopyWith(
          _$_LoadingContent value, $Res Function(_$_LoadingContent) then) =
      __$$_LoadingContentCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> fileNames, String selectedFileName});
}

/// @nodoc
class __$$_LoadingContentCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_LoadingContent>
    implements _$$_LoadingContentCopyWith<$Res> {
  __$$_LoadingContentCopyWithImpl(
      _$_LoadingContent _value, $Res Function(_$_LoadingContent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileNames = null,
    Object? selectedFileName = null,
  }) {
    return _then(_$_LoadingContent(
      null == fileNames
          ? _value._fileNames
          : fileNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      null == selectedFileName
          ? _value.selectedFileName
          : selectedFileName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_LoadingContent implements _LoadingContent {
  const _$_LoadingContent(final List<String> fileNames, this.selectedFileName)
      : _fileNames = fileNames;

  final List<String> _fileNames;
  @override
  List<String> get fileNames {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileNames);
  }

  @override
  final String selectedFileName;

  @override
  String toString() {
    return 'InspectState.loadingContent(fileNames: $fileNames, selectedFileName: $selectedFileName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoadingContent &&
            const DeepCollectionEquality()
                .equals(other._fileNames, _fileNames) &&
            (identical(other.selectedFileName, selectedFileName) ||
                other.selectedFileName == selectedFileName));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_fileNames), selectedFileName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LoadingContentCopyWith<_$_LoadingContent> get copyWith =>
      __$$_LoadingContentCopyWithImpl<_$_LoadingContent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return loadingContent(fileNames, selectedFileName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return loadingContent?.call(fileNames, selectedFileName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (loadingContent != null) {
      return loadingContent(fileNames, selectedFileName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return loadingContent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return loadingContent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (loadingContent != null) {
      return loadingContent(this);
    }
    return orElse();
  }
}

abstract class _LoadingContent implements InspectState {
  const factory _LoadingContent(
          final List<String> fileNames, final String selectedFileName) =
      _$_LoadingContent;

  List<String> get fileNames;
  String get selectedFileName;
  @JsonKey(ignore: true)
  _$$_LoadingContentCopyWith<_$_LoadingContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ErrorCopyWith<$Res> {
  factory _$$_ErrorCopyWith(_$_Error value, $Res Function(_$_Error) then) =
      __$$_ErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace? stackTrace});
}

/// @nodoc
class __$$_ErrorCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_Error>
    implements _$$_ErrorCopyWith<$Res> {
  __$$_ErrorCopyWithImpl(_$_Error _value, $Res Function(_$_Error) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = freezed,
  }) {
    return _then(_$_Error(
      null == exception ? _value.exception : exception,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$_Error implements _Error {
  const _$_Error(this.exception, this.stackTrace);

  @override
  final Object exception;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'InspectState.error(exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Error &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(exception), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ErrorCopyWith<_$_Error> get copyWith =>
      __$$_ErrorCopyWithImpl<_$_Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return error(exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return error?.call(exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(exception, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements InspectState {
  const factory _Error(final Object exception, final StackTrace? stackTrace) =
      _$_Error;

  Object get exception;
  StackTrace? get stackTrace;
  @JsonKey(ignore: true)
  _$$_ErrorCopyWith<_$_Error> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ErrorContentCopyWith<$Res> {
  factory _$$_ErrorContentCopyWith(
          _$_ErrorContent value, $Res Function(_$_ErrorContent) then) =
      __$$_ErrorContentCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {Object exception,
      StackTrace stackTrace,
      List<String> fileNames,
      String selectedFileName});
}

/// @nodoc
class __$$_ErrorContentCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_ErrorContent>
    implements _$$_ErrorContentCopyWith<$Res> {
  __$$_ErrorContentCopyWithImpl(
      _$_ErrorContent _value, $Res Function(_$_ErrorContent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
    Object? fileNames = null,
    Object? selectedFileName = null,
  }) {
    return _then(_$_ErrorContent(
      null == exception ? _value.exception : exception,
      null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      null == fileNames
          ? _value._fileNames
          : fileNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      null == selectedFileName
          ? _value.selectedFileName
          : selectedFileName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ErrorContent implements _ErrorContent {
  const _$_ErrorContent(this.exception, this.stackTrace,
      final List<String> fileNames, this.selectedFileName)
      : _fileNames = fileNames;

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;
  final List<String> _fileNames;
  @override
  List<String> get fileNames {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileNames);
  }

  @override
  final String selectedFileName;

  @override
  String toString() {
    return 'InspectState.errorContent(exception: $exception, stackTrace: $stackTrace, fileNames: $fileNames, selectedFileName: $selectedFileName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ErrorContent &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            const DeepCollectionEquality()
                .equals(other._fileNames, _fileNames) &&
            (identical(other.selectedFileName, selectedFileName) ||
                other.selectedFileName == selectedFileName));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(exception),
      stackTrace,
      const DeepCollectionEquality().hash(_fileNames),
      selectedFileName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ErrorContentCopyWith<_$_ErrorContent> get copyWith =>
      __$$_ErrorContentCopyWithImpl<_$_ErrorContent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return errorContent(exception, stackTrace, fileNames, selectedFileName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return errorContent?.call(
        exception, stackTrace, fileNames, selectedFileName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (errorContent != null) {
      return errorContent(exception, stackTrace, fileNames, selectedFileName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return errorContent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return errorContent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (errorContent != null) {
      return errorContent(this);
    }
    return orElse();
  }
}

abstract class _ErrorContent implements InspectState {
  const factory _ErrorContent(
      final Object exception,
      final StackTrace stackTrace,
      final List<String> fileNames,
      final String selectedFileName) = _$_ErrorContent;

  Object get exception;
  StackTrace get stackTrace;
  List<String> get fileNames;
  String get selectedFileName;
  @JsonKey(ignore: true)
  _$$_ErrorContentCopyWith<_$_ErrorContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ContentCopyWith<$Res> {
  factory _$$_ContentCopyWith(
          _$_Content value, $Res Function(_$_Content) then) =
      __$$_ContentCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<String> fileNames,
      String selectedFileName,
      List<List<String>> csv});
}

/// @nodoc
class __$$_ContentCopyWithImpl<$Res>
    extends _$InspectStateCopyWithImpl<$Res, _$_Content>
    implements _$$_ContentCopyWith<$Res> {
  __$$_ContentCopyWithImpl(_$_Content _value, $Res Function(_$_Content) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileNames = null,
    Object? selectedFileName = null,
    Object? csv = null,
  }) {
    return _then(_$_Content(
      null == fileNames
          ? _value._fileNames
          : fileNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      null == selectedFileName
          ? _value.selectedFileName
          : selectedFileName // ignore: cast_nullable_to_non_nullable
              as String,
      null == csv
          ? _value._csv
          : csv // ignore: cast_nullable_to_non_nullable
              as List<List<String>>,
    ));
  }
}

/// @nodoc

class _$_Content implements _Content {
  const _$_Content(final List<String> fileNames, this.selectedFileName,
      final List<List<String>> csv)
      : _fileNames = fileNames,
        _csv = csv;

  final List<String> _fileNames;
  @override
  List<String> get fileNames {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_fileNames);
  }

  @override
  final String selectedFileName;
  final List<List<String>> _csv;
  @override
  List<List<String>> get csv {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_csv);
  }

  @override
  String toString() {
    return 'InspectState.content(fileNames: $fileNames, selectedFileName: $selectedFileName, csv: $csv)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Content &&
            const DeepCollectionEquality()
                .equals(other._fileNames, _fileNames) &&
            (identical(other.selectedFileName, selectedFileName) ||
                other.selectedFileName == selectedFileName) &&
            const DeepCollectionEquality().equals(other._csv, _csv));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_fileNames),
      selectedFileName,
      const DeepCollectionEquality().hash(_csv));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ContentCopyWith<_$_Content> get copyWith =>
      __$$_ContentCopyWithImpl<_$_Content>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> fileNames, String selectedFileName)
        loadingContent,
    required TResult Function(Object exception, StackTrace? stackTrace) error,
    required TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)
        errorContent,
    required TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)
        content,
  }) {
    return content(fileNames, selectedFileName, csv);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult? Function(Object exception, StackTrace? stackTrace)? error,
    TResult? Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult? Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
  }) {
    return content?.call(fileNames, selectedFileName, csv);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> fileNames, String selectedFileName)?
        loadingContent,
    TResult Function(Object exception, StackTrace? stackTrace)? error,
    TResult Function(Object exception, StackTrace stackTrace,
            List<String> fileNames, String selectedFileName)?
        errorContent,
    TResult Function(List<String> fileNames, String selectedFileName,
            List<List<String>> csv)?
        content,
    required TResult orElse(),
  }) {
    if (content != null) {
      return content(fileNames, selectedFileName, csv);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_LoadingContent value) loadingContent,
    required TResult Function(_Error value) error,
    required TResult Function(_ErrorContent value) errorContent,
    required TResult Function(_Content value) content,
  }) {
    return content(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_LoadingContent value)? loadingContent,
    TResult? Function(_Error value)? error,
    TResult? Function(_ErrorContent value)? errorContent,
    TResult? Function(_Content value)? content,
  }) {
    return content?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_LoadingContent value)? loadingContent,
    TResult Function(_Error value)? error,
    TResult Function(_ErrorContent value)? errorContent,
    TResult Function(_Content value)? content,
    required TResult orElse(),
  }) {
    if (content != null) {
      return content(this);
    }
    return orElse();
  }
}

abstract class _Content implements InspectState {
  const factory _Content(final List<String> fileNames,
      final String selectedFileName, final List<List<String>> csv) = _$_Content;

  List<String> get fileNames;
  String get selectedFileName;
  List<List<String>> get csv;
  @JsonKey(ignore: true)
  _$$_ContentCopyWith<_$_Content> get copyWith =>
      throw _privateConstructorUsedError;
}
